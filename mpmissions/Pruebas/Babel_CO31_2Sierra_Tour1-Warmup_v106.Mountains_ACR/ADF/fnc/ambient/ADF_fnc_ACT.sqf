/*********************************************************************************
 _____ ____  _____ 
|  _  |    \|   __|
|     |  |  |   __|
|__|__|____/|__|   
ARMA Mission Development Framework
ADF version: 2.06 / JUN 2018

Script: Ambient Civilian Traffic (ACT)
Author: Whiztler
Script version: 1.11

File: ADF_fnc_ACT.sqf
**********************************************************************************
ABOUT
The ACT function checks for valid road position to create a vehicle and checks for
valid road positions for waypoints. It is error correcting, meaning if no valid
positions are found then the vehicle and crew are deleted and the search cycle
starts again after 10 seconds.

DO NOT edit this file. This function is used by the ADF_mod_ACT module which can
be found in the 'mission\modules' folder.
*********************************************************************************/

// Check if the module is executed on the server and if the module needs to run at all.
if (!isServer) exitWith {};
if (isNil "ADF_ACT_vehiclesMax" && isNil "ADF_ACT_manMax") exitWith {};
if (ADF_ACT_vehiclesMax == 0 && ADF_ACT_manMax == 0) exitWith {};

// Reporting
if (ADF_debug || ADF_extRpt || time < 180) then {diag_log "ADF RPT: fnc - executing: ADF_fnc_ACT"};

// Check if already running. If so, reset the module.
if (!isNil "ADF_ACT_execute") then {
	ADF_ACT_vTerminate = true;
	waitUntil {!ADF_ACT_execute};
};

// Init
ADF_ACT_execute = true;
ADF_ACT_vTerminate = false;
ADF_ACT_vehicles = [];
ADF_ACT_man = [];

ADF_ACT_searchHouses = {
	// init
	params [
		["_p", [], [[]]]
	]; 
	private _h = [];
	private _bs = nearestObjects [_p, ["House"], ADF_ACT_manRadiusTerm];
	
	if (count _bs == 0) exitWith {if (ADF_debug || ACT_debug) then {[format ["ADF_MOD_ACT - ADF_ACT_searchHouses: No buildings found at %1", _p]] call ADF_fnc_log;}; _h};
	{
		if (_x getVariable ["ADF_ACT_validHouse", false]) then {
			_h pushBack _x;
		} else {
			private _b = _x;
			{
				private _y = [_x, (str (typeOf _b))] call BIS_fnc_inString;
				if (_y) then {_h pushBackUnique _b; _b setVariable ["ADF_ACT_validHouse", true]};
			} forEach ADF_ACT_houseTypes;
		};
	} forEach _bs;

	_h
};

ADF_ACT_searchRoadPos = {
	// Init
	params [
		["_p", [], [[]], [3]],
		["_r", 1500, [0]],
		["_f", true, [false]],
		["_c", 10, [0]]
	];
	private _rd = [];
	private _i = 0;
	private _s = random 360;
	private _n = round (random 9999);
	private _rr = 150;
	if (_f && _r < 1250) then {_r = 1250};
	
	// Debug reporting
	if (ADF_debug) then {[format ["ADF_ACT_searchRoadPos - radius: %1", _r]] call ADF_fnc_log;};

	// Find road position within the parameters (near to the random position)
	for "_i" from 1 to _c do {
		private _k = [_p, _r, _s] call ADF_fnc_randomPosMax;
		_rd = [_k, _rr] call ADF_fnc_roadPos;		
		if (isOnRoad _rd) exitWith {_p = _rd};
		_s = _s + 36;
		_r = _r + 100;
		_rr = _rr + 25;
		if (_i == 10) exitWith {_p = false};
		if (ACT_debug) then {[format ["ADF_ACT_searchRoadPos - Search ID #%1, Searched %2 times", _n, _i]] call ADF_fnc_log;};
	};
	
	// Debug marker
	if (ACT_debug) then {[_p, false, grpNull, "road", _i] call ADF_fnc_positionDebug};
	
	// Return the road position
	_p
};

ADF_ACT_addToZeus = {
	// Init
	params [
		["_o", objNull, [objNull]]		
	];
	
	// Add the man/vehicle to zeus
	if !(isNil "GMmod_1") then {GMmod_1 addCuratorEditableObjects [[_o], true]};
	if !(isNil "GMmod_2") then {GMmod_2 addCuratorEditableObjects [[_o], true]};
	
	true
};

ADF_ACT_createMan = {
	// Init
	params [
		["_p", [], [[]]],
		["_c", 1, [0]]
	]; 
	private _o = selectRandom ADF_civilian_man;
	private _c = ADF_ACT_manMax - _c;

	private _b = [_p] call ADF_ACT_searchHouses;
	
	// Check if we need to spawn more civilian units
	if (count _b == 0) exitWith {if (ADF_debug || ACT_debug) then {[format ["ADF_MOD_ACT - ADF_ACT_createMan: No buildings found to spawn units at %1", _p]] call ADF_fnc_log;}};
	if (count ADF_ACT_man > (ADF_ACT_manMax + 1)) exitWith {if (ADF_debug || ACT_debug) then {[format ["ADF_MOD_ACT - ADF_ACT_createMan: Maximum number of man already spawned", count ADF_ACT_man]] call ADF_fnc_log;}};
	
	for "_i" from 1 to _c do {
		private _p = getPosATL (selectRandom _b);

		// Create the civilian unit
		private _g = createGroup civilian;
		_o createUnit [_p, _g];
		private _u = leader _g;
		_g setVariable ["ADF_noHC_transfer", true];
		_u setVariable ["BIS_enableRandomization", false];
		
		if (ADF_debug) then {[format ["ADF_MOD_ACT - ADF_ACT_createMan: Spawned %1 civilian (%2) at position %3", _o, _u, _p]] call ADF_fnc_log;};

		ADF_ACT_man pushBack _u;

		// Strip and redress the vanilla units. Leave  CUP units as is. 
		private _w = selectRandom ADF_civilian_uniforms;
		if !(ADF_mod_CUP_U) then {
			[_u] call ADF_fnc_stripUnit;	
			_u forceAddUniform _w;
		};
		
		// Make the driver ignore combat as much as possible but allow him to flee
		[_u] call ADF_fnc_heliPilotAI;
		_g allowFleeing 0.4;
		
		// Create random waypoints. Instruct the man to visit friends in other houses (ADF_fnc_searchBuilding)
		for "_z" from 0 to (floor (3 + random 3)) do {
			private _p = getPosATL (selectRandom _b);
			[_g, _p, 50, "MOVE", "SAFE", "WHITE", "LIMITED", "COLUMN", 5, "foot", true] call ADF_fnc_addWaypoint;
		};
		_wp = _g addWaypoint [_p, (count waypoints _g)];
		_wp setWaypointType "CYCLE";	
		
		// Add the unit to Zeus
		[_u] call ADF_ACT_addToZeus;		
	};
	true
};

ADF_ACT_carToManTransfer = {
	// Function is called by the EH that fires up when a driver disembarks its vehicle
	
	// Init
	params [
		["_v", objNull, [objNull]],
		["_c", "", [""]],
		["_u", objNull, [objNull]]
	];
		
	// Delete the vehicle
	[_v] spawn {
		params ["_v"];
		
		// Remove the empty vehicle from the vehicle array
		ADF_ACT_vehicles = ADF_ACT_vehicles - [_v];
		
		// Check if the empty vehicle is close to any players. If so wait until this is not the case
		private _a = [];
		{if (alive _x) then {_a pushBack _x}} forEach (allPlayers - entities "HeadlessClient_F");
		waitUntil {{_v distance2D _x > 300} forEach _a; sleep 5;};
		
		// Vehicle is minn 300 meters away. Lets delete it
		if (ADF_debug || ACT_debug) then {[format ["ADF_ACT_carToManTransfer - Driver disembarked its vehicle (%1). Deleting the vehicle.", _v]] call ADF_fnc_log;};
		[_v] call ADF_fnc_delete;
	};
	
	// Add the driver to the man array.
	ADF_ACT_man pushBack _u;
	if (ADF_debug || ACT_debug) then {[format ["ADF_ACT_carToManTransfer - Disembarked driver (%1) added to the ADF_ACT_man array", _u]] call ADF_fnc_log;};
	
	true	
};

ADF_ACT_createVehicle = {
	// Init
	params [
		["_p", [], [[]]]
	]; 
	private _a = selectRandom ADF_civilian_wheeled_vehicles;
	
	// Check if we are maxed out with civilian vehicles
	if (count ADF_ACT_vehicles >= ADF_ACT_vehiclesMax) exitWith {};	
	
	// Copy the passed (player) position and find a road within the given radius of the position
	_z = _p;
	_p = [_p, ADF_ACT_vehiclesRadiusSpawn] call ADF_ACT_searchRoadPos;
	if (typeName _p isEqualTo "BOOL") exitWith {if (ADF_debug || ACT_debug) then {[format ["ADF_ACT_createVehicle - ERROR! No road position found (%1)", _p]] call ADF_fnc_log;};false}; 

	// Get the direction of the road so the car spawns in the correct direction
	private _d = [_p] call ADF_fnc_roadDir;
	
	// Create the vehicle, group and crew
	private _v = [_p, _d, _a] call ADF_fnc_createCrewedVehicle;
	_c = (_v select 1) select 0;
	_g = _v select 2;
	_v = _v select 0;
	
	// Add an EH in case the car gets damaged and the driver disembarks
	_v addEventHandler ["GetOut", {[_this select 0, _this select 1, _this select 2] spawn ADF_ACT_carToManTransfer}];
	
	// Set variables for Headless client balancers and silly vehicle skin randomization
	_g setVariable ["ADF_noHC_transfer", true];
	_v setVariable ["BIS_enableRandomization", false];
	
	// Add the new vehicle to the vehicles array
	ADF_ACT_vehicles pushBack _v;

	// Strip and redress the driver
	private _u = selectRandom ADF_civilian_uniforms;
	[_c] call ADF_fnc_stripUnit;	
	_c forceAddUniform _u;
	
	// Make the driver ignore combat as much as possible
	[_c] call ADF_fnc_heliPilotAI; 
	
	// Check if all is good and send the driver on its way else delete the service
	if ((_g isEqualTo grpNull) || (_v isEqualTo objNull)) exitWith {
		if (ADF_Debug || ACT_debug) then {[format ["ADF_ACT_createVehicle - ERROR! ObjNull (%1) or GrpNull (%2)", _v, _g]] call ADF_fnc_log};
		ADF_ACT_vehicles = ADF_ACT_vehicles - [_v];
		[_v] call ADF_fnc_delete;		
		false
	};
	private _t = selectRandom [false, false, true, false];
	[_c, ADF_ACT_vehiclesRadiusTerm + ADF_ACT_vehiclesRadiusSpawn, _t, _z, _v] call ADF_ACT_vehicleWaypoint;
	_v limitSpeed 80;	
	
	// Add the vehicle to Zeus
	[_v] call ADF_ACT_addToZeus;
	
	true
};

ADF_ACT_vehicleWaypoint = {
	// Init
	params [
		["_c", objNull, [objNull]],
		["_r", 5000, [0]],
		["_f", false, [true]],
		["_z", [], [[]], [3]],
		["_v", objNull, [objNull]]
	];
	private _p = [];
	private _w = 250;
	
	// Check if the initial waypoint is around a player position
	if (_f) then {
		// Player waypoint it is
		_p = _z;
		_w = 350;
	} else {
		// Get a random driving waypoint in the given radius
		private _l = nearestLocations [getPosWorld _c, ["NameVillage", "NameCity", "NameCityCapital", "NameLocal", "CityCenter"], _r];
		if (count _l == 0) then { // v1.09
			_p = [getPos _v, 2500] call ADF_ACT_searchRoadPos;
		} else {
			_p = locationPosition (_l select (floor (random (count _l))));
		};
	};
	
	// Position check
	_p = [_p] call ADF_fnc_checkPosition;
	if (_p isEqualTo [0,0,0]) exitWith {["ADF_ACT_vehicleWaypoint",format ["Incorrect position passed for : %C (%2)", group _c, _p]] call ADF_fnc_terminateScript; false};
		
	// Debug marker
	if (ADF_debug) then {[_p, false, grpNull, "road", 99] call ADF_fnc_positionDebug};	
	
	// Check for a valid road location. If no valid location is found then delete the vehicle plus its driver and exit the process.
	_p = [_p, _w, false, 4] call ADF_ACT_searchRoadPos;
	if !(isOnRoad _p) exitWith {
		if (ADF_Debug || ACT_debug) then {[format ["ADF_ACT_vehicleWaypoint - ERROR! Could not find a WP for %1 within %2 meters of %3. Deleting the vehicle + crew.", _v, _w, _p]] call ADF_fnc_log};
		ADF_ACT_vehicles = ADF_ACT_vehicles - [_v];
		[_v] call ADF_fnc_delete;
		false
	};
	
	// We have a valid road location. Let's create the waypoint.
	private _wp = (group _c) addWaypoint [_p, 0];
	_wp setWaypointType "MOVE";
	_wp setWaypointBehaviour "SAFE";
	_wp setWaypointCompletionRadius 25;
	_wp setWaypointStatements ["true", "[this] call ADF_ACT_vehicleWaypoint"];
	
	true
};

ADF_ACT_deleteMan = {
	// Init
	params [
		["_a", [], [[]]]
	];

	if (count _a == 0) then {
		{if (alive _x) then {_a pushBack _x}} forEach (allPlayers - entities "HeadlessClient_F");
	};

	{if (!alive _x or isNull _x) then {ADF_ACT_man set [_forEachIndex, objNull]}} forEach ADF_ACT_man;
	ADF_ACT_man = ADF_ACT_man - [objNull];	

	{
		private _u = _x;
		private _cm = 0;
		
		// Check the distance players - civilian men
		{if (_u distance2D _x > ADF_ACT_manRadiusTerm) then {_cm = _cm + 1}} forEach _a;

		if (_cm == (count _a)) then {
			ADF_ACT_man = ADF_ACT_man - [_u];
			_g = group _u;
			[_g] call ADF_fnc_delete;
		};
	} forEach ADF_ACT_man;
	true
};

ADF_ACT_deleteVehicle = {
	// Init
	params [
		["_a", [], [[]]]
	];
	
	if (count _a == 0) then {
		{if (alive _x) then {_a pushBack _x}} forEach (allPlayers - entities "HeadlessClient_F");
	};

	{
		private _c = 0;
		private _v = _x;
		
		// Check the distance players - civilian vehicles
		{if (_v distance2D _x > ADF_ACT_vehiclesRadiusTerm) then {_c = _c + 1}} forEach _a;
		
		if (_c == (count _a)) then {		
			ADF_ACT_vehicles = ADF_ACT_vehicles - [_v];
			[_v] call ADF_fnc_delete;
		};
	} forEach ADF_ACT_vehicles;
	true
};

// Start the ACT activation cycle. Checks and executes every 10 secs
[] spawn {
	waitUntil {
		// Init the player array. Repopulate every cycle.
		private _a = [];

		// Populate the array with players
		{if (alive _x) then {_a pushBack _x}} forEach (allPlayers - entities "HeadlessClient_F");
		
		if (ADF_ACT_vehiclesMax > 0 ) then {[_a] call ADF_ACT_deleteVehicle};
		if (ADF_ACT_manMax > 0) then {[_a] call ADF_ACT_deleteMan};
		
		{
			private _u = _x;
			private _cv = 0;
			private _cm = 0;
			
			if (ADF_ACT_vehiclesMax > 0 ) then {
				{if (_x distance2D _u < ADF_ACT_vehiclesRadiusTerm) then {_cv = _cv + 1}} forEach ADF_ACT_vehicles;
				if (_cv < ADF_ACT_vehiclesMax) then {[getPosWorld _u] call ADF_ACT_createVehicle};				
			};
			if (ADF_ACT_manMax > 0) then {				
				{if (_x distance2D _u < ADF_ACT_manRadiusTerm) then {_cm = _cm + 1}} forEach ADF_ACT_man;
				if (_cm < ADF_ACT_manMax) then {[(getPosWorld _u), _cm] call ADF_ACT_createMan;};
			};
			
		} forEach _a;
		
		sleep 10;
		ADF_ACT_vTerminate
	};
};

// Module has stopped. lets set the var to false in case of a module restart.
ADF_ACT_execute = false;

// Lets log the incident in the server RPT
diag_log ""; ["ADF_fnc_ACT - Incident Report: SERVICE TERMINATED"] call ADF_fnc_log; diag_log "";